---
task: "2.3"
title: Code Review
course: TDT4242
group: 17
deadline: 2026-03-02T23:59:00
score: null
status: not-submitted
---

# Task 2.3 - Code Review

## Description

In this task, you will analyse, review, and improve the quality of the codebase produced in Task 2.2. You will apply code review practices to identify and reason about code smells—structural weaknesses that can reduce maintainability, readability, reliability, or performance. You must use at least two (2) of the following review approaches: Manual code review Peer review with classmates AI-assisted code analysis tools (e.g. ChatGPT, GitHub Copilot, SonarLint) Examples of code smells include (but are not limited to): long or overly complex components, duplicated logic, primitive obsession, large classes, long parameter lists, temporary fields, shotgun surgery, dead or unreachable code, excessive comments, deeply nested JSX, mixing UI and business logic, and missing error handling. If peer review is used, participating groups must agree on the collaboration in advance, and the codebase must be made available for review one week before the submission deadline. If AI tools are used, you must: Include sample prompts and responses Clearly state which suggestions were accepted or rejected Explain the reasoning behind these decisions

## Expected Outcome

Code Review Summary Document that: Describes the review method used in sufficient detail to be repeatable Lists identified code smells, including: (1) Name of the smell (2)Short description (3) Identify method (4) Relevant original code snippets

## Evaluation Criteria

Coverage: demonstrates broad and systematic coverage of the codebase, including components, pages, utilities, and data flow. Quality of code smell identification: Focus on meaningful structural issues rather than superficial style problems Documented review methodology: The review process is clearly described and reproducible.

## Review Methodology

Two review approaches were used: **AI-assisted code analysis** and **manual code review**.

### Method 1: AI-Assisted Code Analysis (Claude via Cursor)

**Tool:** Claude (claude-4.6-opus) running inside Cursor IDE with full file access to the repository.

**Process:**

1. Prompt Claude with a request to systematically review every source file in the project (`server/`, `client/`, `tests/`).
2. Claude reads each file in full and analyses it for structural issues.
3. Findings are returned as a list of code smells with name, description, location, and code snippets.
4. The developer reviews each finding, deciding whether to accept or reject it, with reasoning.

**Reproducibility:** Any developer can replicate this by opening the project in Cursor, selecting all source files, and prompting: *"Review these files for code smells. For each smell, provide: (1) the name, (2) a short description, (3) file and line numbers, (4) the relevant code snippet."*

**Sample prompt:**

> Read all source files under `server/`, `client/pages/`, `client/lib/`, and `tests/`. Identify structural code smells — duplicated logic, large functions, magic numbers, missing abstractions, mixing concerns, etc. For each smell, provide the name, a short description, the file and line numbers, and the original code snippet.

**Sample response (excerpt):**

> **Duplicated response mapping** — Every route handler manually maps DB rows to JSON with the same `{ id: e.id, ..., createdAt: e.createdAt.toISOString() }` pattern. Found in `server/routes/logs.ts` (lines 81–89, 134–141), `server/routes/declarations.ts` (lines 146–153, 181–186), `server/routes/classifications.ts` (lines 42–51), `server/routes/alerts.ts` (lines 42–50). A shared `toResponse()` mapper per entity would remove this duplication.

**Decisions on AI suggestions:**

| # | AI Suggestion | Decision | Reasoning |
|---|--------------|----------|-----------|
| 1 | Duplicated response mapping across routes | **Accepted** | Verified: 4 route files repeat the same map-to-JSON pattern |
| 2 | God function in `classifyDeclaration()` | **Accepted** | Function handles 4 requirements, mixes DB queries with business logic and side effects |
| 3 | Magic number `>= 3` for medium risk threshold | **Accepted** | Threshold has no named constant, making it hard to discover or change |
| 4 | Missing admin role check on classifications/alerts | **Accepted** | Verified: `requireAuth()` only checks for a valid JWT, never checks `role` |
| 5 | Primitive obsession in Zod schemas | **Accepted** | `declaredTools` accepts any string array despite having a `toolEnum` in the DB schema |
| 6 | Hardcoded ASSIGNMENTS duplicated across pages | **Accepted** | Confirmed in 5 separate files with two different shapes (array vs Record) |
| 7 | Duplicated TOOL_LABELS across pages | **Accepted** | Same mapping in 3 files |
| 8 | Duplicated success/error message UI blocks | **Accepted** | Identical styled divs in LogUsage and SubmitDeclaration |
| 9 | Duplicated loading/error/empty state pattern | **Accepted** | Same trio of `<Show>` blocks in Classifications, Alerts, UsageHistory |
| 10 | Large component mixing concerns in App.tsx | **Accepted** | 209-line component combines auth, routing, navigation, and login form |
| 11 | Double fetch on mount in UsageHistory | **Accepted** | `onMount` + `createEffect` both call `fetchLogs()` on initial render |
| 12 | Duplicated `login()` helper in test files | **Accepted** | Identical function in all 5 test files |
| 13 | Inconsistent test isolation | **Accepted** | Only 3 of 5 test files use `beforeAll` cleanup |
| 14 | Inline type definitions instead of shared types | **Accepted** | Types like `LogEntry`, `Classification`, `Alert` redefined in each file |

### Method 2: Manual Code Review

**Process:**

1. Read each source file top-to-bottom, checking for: separation of concerns, error handling, duplication, naming, data flow, and security.
2. Cross-reference files to find patterns repeated across modules.
3. Validate and enrich the AI findings with concrete impact analysis.

**Reproducibility:** Open each file in the IDE, read sequentially, and use project-wide search (`grep` / `rg`) to confirm duplication across files. Compare Zod schemas against the Drizzle schema to check for type mismatches.

---

## Code Smell Catalogue

### Smell 1: Duplicated Response Mapping

**Name:** Duplicated Code

**Description:** Every route handler manually maps database rows to JSON response objects using the same pattern: destructure fields and call `.toISOString()` on the timestamp. This logic is repeated in 4 route files (6 occurrences total) with no shared utility function.

**Identification method:** AI-assisted analysis, confirmed by manual cross-file comparison.

**Code snippets:**

`server/routes/logs.ts` — POST handler (lines 81–89):

```typescript
return c.json(
  {
    id: entry.id,
    tool: entry.tool,
    taskTypes: entry.taskTypes,
    assignmentId: entry.assignmentId,
    createdAt: entry.createdAt.toISOString(),
  },
  201,
);
```

`server/routes/logs.ts` — GET handler (lines 134–141):

```typescript
return c.json(
  entries.map((e) => ({
    id: e.id,
    tool: e.tool,
    taskTypes: e.taskTypes,
    assignmentId: e.assignmentId,
    createdAt: e.createdAt.toISOString(),
  })),
  200,
);
```

`server/routes/declarations.ts` — POST handler (lines 146–153):

```typescript
return c.json(
  {
    id: declaration.id,
    assignmentId: declaration.assignmentId,
    declaredTools: declaration.declaredTools,
    createdAt: declaration.createdAt.toISOString(),
  },
  201,
);
```

`server/routes/classifications.ts` — GET handler (lines 42–51):

```typescript
return c.json(
  entries.map((e) => ({
    id: e.id,
    studentId: e.studentId,
    assignmentId: e.assignmentId,
    riskLevel: e.riskLevel,
    undeclaredTools: e.undeclaredTools,
    declaredNotLogged: e.declaredNotLogged,
    createdAt: e.createdAt.toISOString(),
  })),
  200,
);
```

**Impact:** Adding a new field (e.g. `updatedAt`) requires changing every handler. A shared `toLogResponse()`, `toDeclarationResponse()`, etc. would centralise the mapping.

---

### Smell 2: God Function

**Name:** Long Method / God Function

**Description:** The `classifyDeclaration()` function in `server/routes/declarations.ts` (lines 24–86) is a 62-line function that handles four separate requirements (RE-13 risk classification, RE-14 declaration vs log comparison, RE-15 auto-classify trigger, RE-16 alert creation). It mixes database queries, business logic (tool comparison, risk determination), record insertion, and conditional side effects (alert creation) in a single function with no separation of concerns.

**Identification method:** AI-assisted analysis.

**Code snippet:**

`server/routes/declarations.ts` (lines 24–86):

```typescript
async function classifyDeclaration(
  studentId: number,
  assignmentId: number,
  declaredTools: string[],
) {
  // RE-14: Get all logs for this student+assignment
  const logEntries = await db
    .select()
    .from(logs)
    .where(and(eq(logs.studentId, studentId), eq(logs.assignmentId, assignmentId)));

  // RE-14: Compare logged tools vs declared tools
  const loggedTools = [...new Set(logEntries.map((l) => l.tool))];
  const undeclaredTools = loggedTools.filter((t) => !declaredTools.includes(t));
  const declaredNotLogged = declaredTools.filter((t) => !loggedTools.includes(t));

  // RE-13: Determine risk level
  let riskLevel: "low" | "medium" | "high" = "low";

  const hasDirectAnswers = logEntries.some((l) =>
    l.taskTypes.includes("direct_answers"),
  );
  const hasUndeclaredTools = undeclaredTools.length > 0;

  if (hasDirectAnswers || hasUndeclaredTools) {
    riskLevel = "high";
  } else {
    const hasSubstantialTasks = logEntries.some(
      (l) => l.taskTypes.includes("drafting") || l.taskTypes.includes("coding"),
    );
    const hasHighFrequency = logEntries.length >= 3;

    if (hasSubstantialTasks || hasHighFrequency) {
      riskLevel = "medium";
    }
  }

  // Insert classification record
  const [classification] = await db
    .insert(classifications)
    .values({
      studentId,
      assignmentId,
      riskLevel,
      undeclaredTools,
      declaredNotLogged,
    })
    .returning();

  // RE-16: If high risk, create an alert
  if (riskLevel === "high") {
    await db.insert(alerts).values({
      classificationId: classification.id,
      studentId,
      assignmentId,
      riskLevel: "high",
    });
  }

  return classification;
}
```

**Impact:** This function cannot be unit-tested in isolation — testing the risk algorithm requires a full database round trip. Extracting the comparison logic and risk determination into pure functions would improve testability and readability.

---

### Smell 3: Magic Number

**Name:** Magic Number

**Description:** The medium-risk frequency threshold `logEntries.length >= 3` in the risk classification logic has no named constant. The number 3 carries business meaning ("3 or more log entries = high frequency") but is embedded directly in a conditional expression.

**Identification method:** AI-assisted analysis.

**Code snippet:**

`server/routes/declarations.ts` (line 56):

```typescript
const hasHighFrequency = logEntries.length >= 3;
```

**Impact:** If the risk threshold changes, a developer must search through business logic to find the number. A named constant like `const HIGH_FREQUENCY_THRESHOLD = 3` would make the intent clear and the value easy to change.

---

### Smell 4: Missing Role-Based Authorization

**Name:** Missing Error Handling / Security Defect

**Description:** The `GET /api/classifications` and `GET /api/alerts` endpoints are intended for administrators only (per RE-15, RE-16), but the route handlers only call `requireAuth()` which validates the JWT without checking the user's role. Any authenticated student can access all classification and alert data.

**Identification method:** Manual code review — cross-referencing requirements (RE-15: "an administrator calls GET /api/classifications") against the implementation.

**Code snippets:**

`server/routes/classifications.ts` (lines 37–39):

```typescript
async (c) => {
    await requireAuth(c);
    const entries = await db.select().from(classifications);
```

`server/routes/alerts.ts` (lines 37–39):

```typescript
async (c) => {
    await requireAuth(c);
    const entries = await db.select().from(alerts);
```

Compare with `server/lib/auth.ts` (lines 11–24) — `requireAuth` returns the payload but the role is never checked:

```typescript
export async function requireAuth(c: Context) {
  const header = c.req.header("Authorization");
  if (!header?.startsWith("Bearer ")) {
    throw new HTTPException(401, { message: "Missing or invalid token" });
  }

  const token = header.slice(7);
  try {
    const payload = await verify(token, JWT_SECRET, "HS256");
    return payload as { sub: number; role: string };
  } catch {
    throw new HTTPException(401, { message: "Invalid token" });
  }
}
```

**Impact:** A student can view all risk classifications and alerts for all students by calling the admin endpoints directly. The fix would be to add a `requireAdmin()` middleware or check `payload.role === "admin"` in the handler.

---

### Smell 5: Primitive Obsession

**Name:** Primitive Obsession

**Description:** The Zod request schemas for `declaredTools` and `taskTypes` use `z.array(z.string())`, accepting any arbitrary string. However, the database schema defines strict enums (`toolEnum` with values `chatgpt | copilot | claude | other` and `taskTypeEnum` with values `grammar | summarizing | drafting | coding | direct_answers`). The validation layer does not enforce the same constraints as the data layer.

**Identification method:** AI-assisted analysis, confirmed by manual comparison of Zod schemas vs Drizzle schema.

**Code snippets:**

`server/routes/declarations.ts` (lines 10–13) — accepts any string:

```typescript
const createDeclarationSchema = z.object({
  assignmentId: z.number(),
  declaredTools: z.array(z.string()).min(1),
});
```

`server/db/schema.ts` (lines 7–9) — defines strict enums:

```typescript
export const toolEnum = pgEnum("tool", ["chatgpt", "copilot", "claude", "other"]);
export const taskTypeEnum = pgEnum("task_type", ["grammar", "summarizing", "drafting", "coding", "direct_answers"]);
```

The `logs.ts` route does use `z.enum()` for the `tool` field but not for `taskTypes`:

```typescript
const createLogSchema = z.object({
  tool: z.enum(["chatgpt", "copilot", "claude", "other"]),
  taskTypes: z.array(z.string()).min(1),
  assignmentId: z.number(),
});
```

**Impact:** A student could submit a log with `taskTypes: ["anything"]` or a declaration with `declaredTools: ["nonexistent"]`. The database may accept it (the `declared_tools` column is `text[]`, not using the enum) but the risk classification logic would not recognise non-standard values, producing unreliable results.

---

### Smell 6: Duplicated Constant — ASSIGNMENTS

**Name:** Duplicated Code

**Description:** The hardcoded list of assignments appears in 5 separate frontend files with two different shapes: as an array of `{ id, title }` objects in `LogUsage.tsx` and `SubmitDeclaration.tsx`, and as a `Record<number, string>` in `UsageHistory.tsx`, `Classifications.tsx`, and `Alerts.tsx`. The data is also defined in `server/db/seed.ts` — the frontend duplicates must be kept manually in sync.

**Identification method:** AI-assisted analysis, confirmed by searching for `ASSIGNMENTS` across the codebase.

**Code snippets:**

`client/pages/LogUsage.tsx` (lines 37–41) — array shape:

```typescript
const ASSIGNMENTS = [
  { id: 1, title: "Essay on AI Ethics" },
  { id: 2, title: "Programming Assignment 1" },
  { id: 3, title: "Final Project Report" },
];
```

`client/pages/UsageHistory.tsx` (lines 21–25) — Record shape:

```typescript
const ASSIGNMENTS: Record<number, string> = {
  1: "Essay on AI Ethics",
  2: "Programming Assignment 1",
  3: "Final Project Report",
};
```

`client/pages/Alerts.tsx` (lines 21–25) — same Record shape, duplicated:

```typescript
const ASSIGNMENTS: Record<number, string> = {
  1: "Essay on AI Ethics",
  2: "Programming Assignment 1",
  3: "Final Project Report",
};
```

**Impact:** Adding or renaming an assignment requires editing 5 frontend files plus the seed script. A shared `client/lib/constants.ts` or an API endpoint that returns assignments would eliminate this duplication.

---

### Smell 7: Duplicated Constant — TOOL_LABELS

**Name:** Duplicated Code

**Description:** The `TOOL_LABELS` mapping from tool identifiers to display names is defined identically in three separate page components.

**Identification method:** AI-assisted analysis.

**Code snippets:**

`client/pages/LogUsage.tsx` (lines 15–20):

```typescript
const TOOL_LABELS: Record<string, string> = {
  chatgpt: "ChatGPT",
  copilot: "Copilot",
  claude: "Claude",
  other: "Other",
};
```

`client/pages/SubmitDeclaration.tsx` (lines 14–19):

```typescript
const TOOL_LABELS: Record<string, string> = {
  chatgpt: "ChatGPT",
  copilot: "Copilot",
  claude: "Claude",
  other: "Other",
};
```

`client/pages/UsageHistory.tsx` (lines 27–32):

```typescript
const TOOL_LABELS: Record<string, string> = {
  chatgpt: "ChatGPT",
  copilot: "Copilot",
  claude: "Claude",
  other: "Other",
};
```

**Impact:** Adding a new AI tool (e.g. "Gemini") requires editing three files. Extracting to a shared module eliminates the risk of inconsistency.

---

### Smell 8: Duplicated UI Pattern — Success/Error Messages

**Name:** Duplicated Code

**Description:** The success message (green) and error message (red) display blocks use identical Tailwind class strings and the same `<Show when={...}>` wrapper pattern, copy-pasted across form pages.

**Identification method:** AI-assisted analysis.

**Code snippets:**

`client/pages/LogUsage.tsx` (lines 156–167):

```tsx
<Show when={message()}>
  <div class="rounded-md border border-green-200 bg-green-50 px-4 py-3 text-sm text-green-800 dark:border-green-800 dark:bg-green-950 dark:text-green-200">
    {message()}
  </div>
</Show>

<Show when={error()}>
  <div class="rounded-md border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-200">
    {error()}
  </div>
</Show>
```

`client/pages/SubmitDeclaration.tsx` (lines 143–153):

```tsx
<Show when={message()}>
  <div class="rounded-md border border-green-200 bg-green-50 px-4 py-3 text-sm text-green-800 dark:border-green-800 dark:bg-green-950 dark:text-green-200">
    {message()}
  </div>
</Show>

<Show when={error()}>
  <div class="rounded-md border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-200">
    {error()}
  </div>
</Show>
```

**Impact:** A design change to the alert styling (e.g. adding an icon or changing border radius) must be applied in every file. A reusable `<SuccessAlert>` / `<ErrorAlert>` component would centralise the styling.

---

### Smell 9: Duplicated UI Pattern — Loading/Error/Empty State

**Name:** Duplicated Code

**Description:** Three data-fetching pages repeat the same trio of conditional rendering blocks for loading, error, and empty states with nearly identical markup.

**Identification method:** AI-assisted analysis, confirmed by manual comparison.

**Code snippets:**

`client/pages/Classifications.tsx` (lines 73–91):

```tsx
<Show when={loading()}>
  <p class="text-sm text-muted-foreground">
    Loading classifications...
  </p>
</Show>

<Show when={error()}>
  <div class="rounded-md border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-200">
    {error()}
  </div>
</Show>

<Show when={!loading() && !error() && classifications().length === 0}>
  <p class="text-sm text-muted-foreground">
    No classifications found.
  </p>
</Show>
```

`client/pages/Alerts.tsx` (lines 57–71) — same structure, only the text changes:

```tsx
<Show when={loading()}>
  <p class="text-sm text-muted-foreground">Loading alerts...</p>
</Show>

<Show when={error()}>
  <div class="rounded-md border border-red-200 bg-red-50 px-4 py-3 text-sm text-red-800 dark:border-red-800 dark:bg-red-950 dark:text-red-200">
    {error()}
  </div>
</Show>

<Show when={!loading() && !error() && alerts().length === 0}>
  <p class="text-sm text-muted-foreground">No alerts found.</p>
</Show>
```

**Impact:** A reusable `<DataState loading={...} error={...} empty={...} emptyMessage="...">` component or custom hook would eliminate this three-block pattern from every list page.

---

### Smell 10: Large Component Mixing Concerns

**Name:** Large Class / Mixing UI and Business Logic

**Description:** `client/App.tsx` is a 209-line component that combines five distinct responsibilities: (1) authentication state management and localStorage handling, (2) a raw `fetch` call to `/api/auth/login` that bypasses the `api` module, (3) a login form with its own signals, (4) a navigation bar with role-based items, and (5) a page router via `<Switch>`. The `loginRequest()` function in `App.tsx` duplicates the fetch logic that already exists in the `api` module.

**Identification method:** Manual code review.

**Code snippets:**

`client/App.tsx` — raw fetch call (lines 22–35), duplicating logic from `client/lib/api.ts`:

```typescript
async function loginRequest(email: string, password: string) {
  const res = await fetch("/api/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  if (!res.ok) {
    const body = await res.json();
    throw new Error(body.message || "Login failed");
  }
  const body = await res.json();
  localStorage.setItem("token", body.token);
  return body.user as User;
}
```

`client/App.tsx` — onMount session restore (lines 56–81):

```typescript
onMount(async () => {
    const token = localStorage.getItem("token");
    if (token) {
      const res = await fetch("/api/auth/me", {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (res.ok) {
        const u = (await res.json()) as User;
        setUser(u);
        setPage(u.role === "admin" ? "classifications" : "log");
        setLoading(false);
        return;
      }
      localStorage.removeItem("token");
    }
    if (import.meta.env.DEV) {
      try {
        const u = await loginRequest("student@ntnu.no", "password123");
        setUser(u);
      } catch {
        // Seed user doesn't exist yet
      }
    }
    setLoading(false);
  });
```

**Impact:** Any change to authentication logic (e.g. refresh tokens, session expiry) requires modifying the root component. Extracting auth into a dedicated module or context provider, and the login form into its own component, would improve maintainability and separation of concerns.

---

### Smell 11: Double Fetch on Mount

**Name:** Speculative Generality / Redundant Code

**Description:** In `UsageHistory.tsx`, `fetchLogs()` is called twice on initial render — once by `onMount` and once by `createEffect` which tracks the `filter` signal. Since `createEffect` runs immediately when the component mounts (tracking the initial value of `filter()`), the `onMount` call is redundant.

**Identification method:** AI-assisted analysis.

**Code snippet:**

`client/pages/UsageHistory.tsx` (lines 54–60):

```typescript
onMount(fetchLogs);

createEffect(() => {
    // Track the filter signal so the effect re-runs when it changes
    filter();
    fetchLogs();
});
```

**Impact:** Every time the UsageHistory page mounts, two identical API requests are made to `GET /api/logs`. Removing the `onMount(fetchLogs)` line would fix the double-fetch since `createEffect` already handles the initial load.

---

### Smell 12: Duplicated Test Helper — `login()`

**Name:** Duplicated Code

**Description:** An identical `login()` helper function is defined in all 5 test files. The function has the same signature, same default parameters, same implementation.

**Identification method:** AI-assisted analysis.

**Code snippets:**

`tests/auth.test.ts` (lines 5–13):

```typescript
async function login(email = "student@ntnu.no", password = "password123") {
  const res = await app.request("/api/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  const body = await res.json();
  return body.token as string;
}
```

`tests/logs.test.ts` (lines 7–14):

```typescript
async function login(email = "student@ntnu.no", password = "password123") {
  const res = await app.request("/api/auth/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  const body = await res.json();
  return body.token as string;
}
```

Same function repeated in `tests/logs-read.test.ts` (lines 15–23), `tests/declarations.test.ts` (lines 17–25), and `tests/risk.test.ts` (lines 10–18).

**Impact:** If the login endpoint changes (e.g. new field, different URL), all 5 files need updating. A shared `tests/helpers.ts` module exporting `login()` and `createLog()` would centralise this.

---

### Smell 13: Inconsistent Test Isolation

**Name:** Inconsistent Style / Shotgun Surgery

**Description:** Test data cleanup is inconsistent across test files. `tests/risk.test.ts`, `tests/declarations.test.ts`, and `tests/logs-read.test.ts` use `beforeAll` to delete data before running, but `tests/logs.test.ts` and `tests/auth.test.ts` do not. This means test results can depend on execution order when tests run against the same database.

**Identification method:** Manual code review.

**Code snippets:**

`tests/declarations.test.ts` (lines 7–12) — has cleanup:

```typescript
beforeAll(async () => {
  await db.delete(alerts);
  await db.delete(classifications);
  await db.delete(declarations);
  await db.delete(logs);
});
```

`tests/logs.test.ts` — no `beforeAll`, no cleanup. The file starts directly with `describe("POST /api/logs", () => {`.

`tests/auth.test.ts` — no `beforeAll`, no cleanup. Relies on seeded data existing but does not reset state.

**Impact:** If `tests/logs.test.ts` runs after `tests/risk.test.ts`, leftover data from risk tests could affect log test assertions that check counts. A consistent cleanup strategy (either per-file `beforeAll` or a global test setup) would prevent flaky tests.

---

### Smell 14: Inline Type Definitions

**Name:** Primitive Obsession / Duplicated Code

**Description:** Response types are defined inline in multiple places instead of being imported from a shared location. The project generates `client/lib/api-types.d.ts` from the OpenAPI spec, but neither the frontend pages nor the test files use these generated types. Instead, each file defines its own local type.

**Identification method:** AI-assisted analysis.

**Code snippets:**

`tests/risk.test.ts` (lines 6–7):

```typescript
type Classification = { id: number; studentId: number; assignmentId: number; riskLevel: string; undeclaredTools: string[] | null; declaredNotLogged: string[] | null; createdAt: string };
type Alert = { id: number; classificationId: number; studentId: number; assignmentId: number; riskLevel: string; createdAt: string };
```

`tests/logs.test.ts` (line 4):

```typescript
type LogEntry = { id: number; tool: string; taskTypes: string[]; assignmentId: number; createdAt: string };
```

`client/pages/Classifications.tsx` (lines 12–20):

```typescript
type Classification = {
  id: number;
  studentId: number;
  assignmentId: number;
  riskLevel: string;
  undeclaredTools: string[] | null;
  declaredNotLogged: string[] | null;
  createdAt: string;
};
```

`client/lib/api.ts` (lines 23–25) — long inline type annotation:

```typescript
createLog(data: { tool: string; taskTypes: string[]; assignmentId: number }) {
    return apiFetch<{ id: number; tool: string; taskTypes: string[]; assignmentId: number; createdAt: string }>("/api/logs", {
```

**Impact:** If a response shape changes (e.g. adding a field), every inline definition must be updated manually. Importing types from the generated `api-types.d.ts` or a shared `types.ts` would provide a single source of truth.

---

## Summary

### Coverage

The review covered all source files in the project:

| Layer | Files reviewed | Smells found |
|-------|---------------|-------------|
| Backend routes | 5 files (`index.ts`, `auth.ts`, `logs.ts`, `declarations.ts`, `classifications.ts`, `alerts.ts`) | 5 |
| Backend lib/db | 3 files (`auth.ts`, `schema.ts`, `client.ts`, `seed.ts`) | (included in backend smells) |
| Frontend pages | 5 files (`App.tsx`, `LogUsage.tsx`, `UsageHistory.tsx`, `SubmitDeclaration.tsx`, `Classifications.tsx`, `Alerts.tsx`) | 6 |
| Frontend lib | 2 files (`api.ts`, `utils.ts`) | (included in frontend smells) |
| Tests | 6 files | 3 |
| **Total** | **21 files** | **14 code smells** |

### Key Findings

The most prevalent issue is **code duplication** (smells 1, 6, 7, 8, 9, 12, 14), accounting for half of all findings. This is characteristic of AI-generated code, which tends to produce self-contained files by repeating logic rather than creating shared abstractions.

The most impactful issue is **missing role-based authorization** (smell 4), which is a security defect allowing students to access admin-only data.

The most architecturally significant issue is the **god function** (smell 2), where the risk classification engine combines four requirements into one function with no separation between data access and business logic.
